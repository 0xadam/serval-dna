#!/bin/bash

# Tests for Serval rhizome protocol.
#
# Copyright 2012 Serval Project Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

source "${0%/*}/../testframework.sh"
source "${0%/*}/../testdefs.sh"
source "${0%/*}/../testdefs_rhizome.sh"

shopt -s extglob

finally() {
   stop_all_servald_servers
}

teardown() {
   kill_all_servald_processes
   assert_no_servald_processes
   report_all_servald_servers
}

# Called by start_servald_instances for each instance.
configure_servald_server() {
   executeOk_servald config \
      set log.show_pid on \
      set log.show_time on \
      set debug.rhizome on \
      set debug.rhizome_tx on \
      set debug.rhizome_rx on \
      set debug.rhizome_async on \
      set server.respawn_on_crash off \
      set mdp.iftype.wifi.tick_ms 500
}

setup_curl_7() {
   case "$(curl --version | tr '\n' ' ')" in
   curl\ @(7|8|9|[1-9][0-1]).*\ Protocols:*\ http\ *) ;;
   '') fail "curl(1) command is not present";;
   *) fail "curl(1) version is not adequate (expecting 7 or higher)";;
   esac
   unset http_proxy
   unset HTTP_PROXY
   unset HTTPS_PROXY
   unset ALL_PROXY
}

setup_common() {
   setup_servald
   assert_no_servald_processes
   foreach_instance +A +B create_single_identity
   set_instance +B
}

setup_channel() {
   executeOk_servald config \
       set rhizome.direct.channels.a.alphabet_size 256 \
       set rhizome.direct.channels.a.encode_flag false \
       set rhizome.direct.channels.a.in_path $instance_dir/async-in \
       set rhizome.direct.channels.a.max_pending 64 \
       set rhizome.direct.channels.a.max_settle_time 120000 \
       set rhizome.direct.channels.a.message_length 160 \
       set rhizome.direct.channels.a.out_path $instance_dir/async-out \
       set rhizome.direct.channels.a.push_command $instance_dir/async-push \
       set rhizome.direct.channels.a.settle_time 60000 \
       set rhizome.direct.channels.a.max_size 4096 \
       set debug.rhizome_async yes
   mkdir $instance_dir/async-out
 }

doc_channelsetup="Channel setup works"
setup_channelsetup() {
   setup_common
}
test_channelsetup() {
   set_instance +A
   setup_channel
   start_servald_instances +A
}

doc_loadchannelstate="Load channel state"
setup_loadchannelstate() {
   setup_common
}
test_loadchannelstate() {
    set_instance +A
    setup_channel
    start_servald_instances +A
    assertGrep --matches=1 "$LOGA" " RD channel #0 state: 0:0:0:0:0"
}

doc_bundlenotificationonstartup="RD Async is notified of bundles added while shutdown on servald start"
setup_bundlenotificationonstartup() {
   setup_servald
   set_instance +A
   setup_channel
   assert_no_servald_processes
   create_single_identity
   rhizome_add_file file1
   BID1=$BID
   start_servald_instances +A
}
test_bundlenotificationonstartup() {
   assertGrep --matches=1 "$LOGA" "new manifest: BID=$BID"
}


doc_bundlenotificationondeduplication="RD Async only notifies once for each bundle"
setup_bundlenotificationondeduplication() {
   setup_servald
   set_instance +A
   setup_channel
   assert_no_servald_processes
   create_single_identity
   rhizome_add_file file1
   BID1=$BID
   start_servald_instances +A
}
test_bundlenotificationondeduplication() {
   assertGrep --matches=1 "$LOGA" "new manifest: BID=$BID"
   stop_all_servald_servers
   rhizome_add_file file2
   BID2=$BID
   start_servald_instances +A
# Make sure newly added bundle gets advertised ...
   assertGrep --matches=1 "$LOGA" "new manifest: BID=$BID2"
# ... and that previously added bundle did not get re-advertised
   assertGrep --matches=1 "$LOGA" "new manifest: BID=$BID1"
}

doc_bundlenotificationonscan="RD Async is notified of bundles added via scan command"
setup_bundlenotificationonscan() {
   setup_servald +Z
   assert_no_servald_processes
   create_single_identity
   set_instance +Z
   setup_channel
   start_servald_instances +Z
}
test_bundlenotificationonscan() {
   set_instance +Z
   tfw_log SIDZ=$SIDZ
   rhizome_add_file file1
   BID1=$BID
   assertGrep --matches=0 "$LOGZ" "new manifest: BID=$BID"
   executeOk_servald rhizome direct async scan
   wait_until --sleep=2.5 assertGrep --matches=1 "$LOGZ" "new manifest: BID=$BID"
}

doc_bundlenotificationonrx="RD Async is notified of bundles that arrive via rhizome"
setup_bundlenotificationonrx() {
   setup_common
   set_instance +A
   rhizome_add_file file1
   BID1=$BID
   VERSION1=$VERSION
   start_servald_instances +A +B
   foreach_instance +A assert_peers_are_instances +B
   foreach_instance +B assert_peers_are_instances +A
}
test_bundlenotificationonrx() {
   wait_until bundle_received_by $BID1:$VERSION1 +B
   set_instance +B
   executeOk_servald rhizome list ''
   assert_rhizome_list --fromhere=0 file1
   assert_rhizome_received file1   
   assertGrep --matches=1 "$LOGB" "new manifest: BID=$BID"
}

doc_barsqueued="BARs are queued when new bundles observed"
setup_barsqueued() {
   setup_servald
   set_instance +A
   setup_channel
   mkdir $instance_dir/async-out
   assert_no_servald_processes
   create_single_identity
   rhizome_add_file file1
   BID1=$BID
   start_servald_instances +A
}
test_barsqueued() {
   assertGrep --matches=1 "$LOGA" "new manifest: BID=$BID1"
   set_instance +A
   assert [ -e $instance_dir/async-out/queued_manifests ]
   assert [ ! -z $instance_dir/async-out/queued_manifests ]
   qmsize=`ls -l $instance_dir/async-out/queued_manifests | awk '{ print $5}'`
   assert [ $qmsize == 32 ]
}

doc_messagesemitted="Message(s) are emitted when new bundles observed"
test_messagesemitted() {
    assert false
}

doc_messagesemittedonupdate="Message(s) are emitted when a new version of a bundle is observed"
test_messagesemittedonupdate() {
    assert false
}

doc_pushcommandiscalled="Async push command is called when messages are written"
test_pushcommandiscalled() {
    assert false
}

doc_messagesaccepted="Messages are accepted on calling rhizome direct async scan"
test_messagesaccepted() {
    assert false
}

doc_bundlerequestsgenerated="Bundle requests (SENDMEs) generated in response to IHAVE messages"
test_bundlerequestsgenerated() {
    assert false
}

doc_bundlessent="Bundles sent in response to SENDME requests"
test_bundlessent() {
    assert false
}

doc_bundlesreceived="Bundles received via async channel"
test_bundlesreceived() {
    assert false
}

doc_settletimehonoured="rhizome.direct.channels.*.settle_time is honoured"
test_settletimehonoured() {
    assert false
}

doc_maxsettletimehonoured="rhizome.direct.channels.*.max_settle_time is honoured"
test_maxsettletimehonoured() {
    assert false
}

doc_maxsizehonoured="rhizome.direct.channels.*.max_size is honoured"
test_maxsizehonoured() {
    assert false
}

runTests "$@"
